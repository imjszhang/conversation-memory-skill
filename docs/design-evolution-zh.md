# 设计演进：为 Claude 构建记忆系统

> 本文讲述这个项目如何从一个简单的想法，通过迭代设计和问题解决，演进到最终架构的故事。

## 问题

每个 Claude Code 用户都面临一个共同的困扰：**上下文窗口限制**。

当你深入一个复杂的编码会话，讨论架构决策、调试棘手问题、或探索新功能时，对话历史不断增长。最终，上下文窗口满了，你面临选择：

- 清空上下文，丢失宝贵的讨论历史
- 手动把重要部分复制到别处
- 开始新对话，重新解释所有背景

这些选项都不理想。我们真正需要的是一种**自动保存和召回对话上下文**的方法——就像给 Claude 一个记忆。

## 为什么不用传统方案？

显而易见的解决方案是构建一个记忆系统。但让我们看看这通常需要什么：

| 方案 | 需要什么 | 问题 |
|------|----------|------|
| **向量数据库**（Pinecone、Chroma 等） | Embedding API、数据库服务、检索逻辑 | 重基础设施、持续成本、外部依赖 |
| **RAG 系统** | Embedding + 向量搜索 + 分块 + 检索 | 复杂管道、需要调参、对话场景过重 |
| **外部服务**（Mem0 等） | API Key、第三方集成 | 数据隐私问题、服务可用性、供应商锁定 |
| **本地数据库**（SQLite 等） | 数据库配置、查询接口、自定义工具 | Claude 无法原生访问、需要工具集成 |
| **纯文件 + 手动搜索** | 人工操作 | 无法扩展、容易遗忘 |

**共同模式**：这些方案都试图**从外部给 Claude 加一个记忆系统**。

但问题是——如果 Claude 已经有一个类似记忆的机制呢？

## 核心洞察

在阅读 Claude Skills 文档时，我有了一个"啊哈"时刻：

> **Claude Skills 本质上就是一个等待被使用的记忆系统。**

这不是"给 Claude 添加记忆"，而是**认识到 Claude 已经有记忆**——我们只需要换一种方式使用它。

想想记忆系统需要什么，以及 Skills 提供了什么：

| 记忆系统需要 | Claude Skills 提供 |
|-------------|-------------------|
| 触发机制 | description 关键词匹配 |
| 结构化存储 | Markdown + YAML 前置元数据 |
| 按需加载 | 三层渐进式披露 |
| 跨会话持久化 | 文件系统（内置） |
| 无外部依赖 | Claude Code 原生 |

**领悟**：与其在 Claude 外部构建基础设施，不如使用已有的东西。Skills 就是记忆——只是它们不是为此设计的。

这是关键洞察：**不要给 Claude 添加记忆，使用 Claude 已有的记忆。**

## V1 设计：每个记忆作为一个技能

### 概念

第一版设计很直接：**把每个保存的对话作为一个独立的技能**。

```
.claude/skills/memories/
├── mem-20260110-153000/
│   └── SKILL.md          # 包含摘要 + 关键词
├── mem-20260110-160000/
│   └── SKILL.md
└── mem-20260111-090000/
    └── SKILL.md
```

每个记忆包含：
- 带有关键词的 YAML 前置元数据的 `SKILL.md`
- 对话摘要
- `references/` 文件夹中的原始对话

### 实现

我们创建了：
- `save_memory.js` - 生成带有 SKILL.md 文件的记忆目录
- `activate_memory.js` - 将归档记忆移回活跃状态
- `archive_old_memories.js` - 将旧记忆移至归档

### 发现的问题

实现 V1 后，我意识到一个关键缺陷：

**Claude Skills 在启动时加载所有技能的 description。**

这意味着：
- 10 个记忆 = 10 条 description 被加载
- 100 个记忆 = 100 条 description 被加载
- 即使是归档的记忆，如果在 skills 文件夹中也会被加载

这完全违反了**渐进式披露**原则。我们不是按需加载记忆细节，而是预先加载所有元数据，导致：

1. **上下文膨胀** - 宝贵的上下文空间浪费在记忆元数据上
2. **无真正归档** - 归档记忆仍然消耗资源
3. **扩展问题** - 记忆越多 = 性能越差

## V2 设计：单技能 + 动态索引

### 新方案

解决方案是反转架构：

**不是多个技能各存一个记忆，而是用一个技能索引所有记忆。**

```
.claude/skills/conversation-memory/
├── SKILL.md              # 带动态索引的单一技能
├── scripts/              # 管理脚本
└── memories/
    ├── active/           # 活跃记忆（普通文件，不是技能）
    │   └── mem-xxx/
    │       ├── summary.md
    │       └── conversation.md
    └── archive/          # 归档记忆（完全不加载）
```

### 关键变化

1. **记忆不是技能** - 它们是普通 Markdown 文件
2. **带索引的单一技能** - 主 SKILL.md 包含索引表
3. **动态关键词** - 技能的 `description` 包含所有活跃记忆的关键词
4. **真正的归档** - 归档记忆完全在技能系统之外

### 索引机制

主 SKILL.md 现在包含：

```yaml
---
name: conversation-memory
description: >
  记忆管理。关键词：react, hooks, performance, debugging...
---

## 活跃记忆索引

| ID | 主题 | 关键词 | 日期 |
|----|------|--------|------|
| mem-001 | React Hooks | hooks, state | 2026-01-10 |
| mem-002 | 性能优化 | optimization | 2026-01-11 |
```

新脚本 `update_index.js` 扫描活跃记忆并更新：
- SKILL.md 中的索引表
- description 中的关键词列表

### 四层加载

这创建了一个清晰的四层渐进式加载系统：

```
第 0 层：description 关键词  → 始终加载（约 100 字符）
第 1 层：SKILL.md 索引表    → 技能匹配时加载
第 2 层：summary.md         → 按需加载
第 3 层：conversation.md    → 完整溯源时加载
```

## V3 设计：独立索引文件

### 优化

实现 V2 后，我注意到另一个问题：SKILL.md 混合了两个关注点：

1. **技能定义** - 触发器、指令、工作流（静态）
2. **记忆索引** - 活跃记忆表（动态）

每次保存记忆，整个 SKILL.md 都要重写，只是为了更新索引表。

### 解决方案

将索引移到独立文件：

```
conversation-memory/
├── SKILL.md              # 仅技能定义（稳定）
└── memories/
    ├── index.md          # 动态索引（频繁更新）
    ├── active/
    └── archive/
```

现在：
- `SKILL.md` 只包含技能定义和指令
- `memories/index.md` 包含动态索引表
- `description` 仍包含关键词（用于第 0 层匹配）

### 最终架构

```
第 0 层：SKILL.md description      → 匹配用关键词
第 1 层：memories/index.md         → 索引表查找
第 2 层：active/mem-xxx/summary.md → 详细摘要
第 3 层：active/mem-xxx/conversation.md → 完整原始对话
```

这种分离提供了：
- **稳定性** - SKILL.md 很少变化
- **单一职责** - 每个文件只做一件事
- **干净更新** - 索引变化不影响技能定义

## 为什么这个设计更好

经过三次迭代，最终设计有两个最重要的优势：

### 极简

| 方面 | 本项目 | 传统方案 |
|------|--------|----------|
| 依赖 | 零 | 向量数据库、Embedding API 等 |
| 基础设施 | 无 | 数据库服务、API 端点 |
| 成本 | 免费 | Embedding 费用、存储费用 |
| 配置 | 复制一个文件夹 | 部署服务、配置 API |
| 格式 | 纯文本（人类可读） | 二进制 embedding、数据库记录 |
| 版本控制 | Git 友好 | 需要特殊处理 |

**你只需复制一个文件夹就能用。** 无 API Key、无服务、无成本。

### 可扩展

极简设计不意味着功能受限。你可以扩展它：

- **添加向量搜索**：为摘要生成 embedding 实现语义召回（可选增强，非必需）
- **跨项目记忆**：在项目间符号链接或复制记忆
- **自定义召回逻辑**：修改脚本改变记忆查找方式
- **外部集成**：需要时导出到其他系统
- **团队共享**：通过 Git 共享记忆

**关键洞察**：从极简开始，只在需要时添加复杂性。大多数场景不需要 embedding 或向量搜索——基于写得好的摘要的关键词匹配效果出奇地好。

## 经验教训

### 1. 先理解平台

在构建之前，深入理解 Claude Skills 如何工作：
- 什么时候加载什么？
- 性能影响是什么？
- 匹配系统如何工作？

### 2. 渐进式披露是关键

不要预先加载所有内容。设计时考虑：
- 最小初始加载
- 按需扩展
- 清晰的细节层级分离

### 3. 基于真实问题迭代

每个版本都解决了上一版本发现的真实问题：
- V1 → V2：修复元数据膨胀
- V2 → V3：修复关注点混合

### 4. 模仿自然系统

最终设计模仿了人类记忆的工作方式：
- **关键词触发回忆** - 就像一个词可以唤起记忆
- **渐进式细节** - 先想起大概，再想起细节
- **用进废退** - 活跃记忆保持，不活跃的逐渐淡化
- **冗余是可以的** - 同一主题的多个记忆没问题

## 下一步

潜在的未来改进：
- **语义搜索** - 使用 embedding 实现更好的召回
- **自动摘要** - 自动压缩旧记忆
- **跨项目记忆** - 在项目间共享记忆
- **记忆整合** - 随时间合并相关记忆

---

*这段设计之旅表明，构建有效工具不仅需要编码技能，还需要深入理解平台并基于真实反馈进行迭代。*
